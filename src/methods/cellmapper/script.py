import anndata as ad
import numpy as np
import scanpy as sc
from scipy.sparse import issparse
import cellmapper as cm

## VIASH START
# Note: this section is auto-generated by viash at runtime. To edit it, make changes
# in config.vsh.yaml and then run `viash config inject config.vsh.yaml`.
par = {
  'input_train': 'resources_test/task_denoising/cxg_immune_cell_atlas/train.h5ad',
  'output': 'output_cellmapper.h5ad',
  'kernel_method': 'umap',
  'norm': 'log',
  't': 3
}
meta = {
  'name': 'cellmapper'
}
## VIASH END

print(f'CellMapper version: {cm.__version__}', flush=True)

print('Reading input files', flush=True)
input_train = ad.read_h5ad(par['input_train'])

print('Prepare the AnnData object', flush=True)

# Let's make sure we have counts in .X
input_train.X = input_train.layers["counts"].copy()

print('Preprocess the data', flush=True)
sc.pp.normalize_total(input_train, target_sum=1e4)

if par['norm'] == 'sqrt':
    # Safe square root for both sparse and dense matrices
    if issparse(input_train.X):
        input_train.X.data = np.sqrt(input_train.X.data)
    else:
        input_train.X = np.sqrt(input_train.X)
elif par['norm'] == 'log':
    sc.pp.log1p(input_train)
else:
    raise ValueError(f"Unknown normalization method: {par['norm']}")

sc.pp.highly_variable_genes(input_train)
sc.pp.pca(input_train)

print('Setup and prepare CellMapper', flush=True)

# Initialize CellMapper with the AnnData object, compute k-NN graph and mapping matrix
cmap = cm.CellMapper(input_train)
cmap.compute_neighbors(use_rep="X_pca")
cmap.compute_mapping_matrix(kernel_method=par['kernel_method'])

print('Run data smoothing', flush=True)

# run t-step smothing and write back to input 
cmap.map_layers(key="counts", t=par['t'])

print("Write output AnnData to file", flush=True)

# Create output AnnData object without X to avoid encoding issues
output = ad.AnnData(
    obs=input_train.obs[[]],
    var=input_train.var[[]],
    uns={
        "dataset_id": input_train.uns["dataset_id"],
        "method_id": meta["name"]
    }
)
# Set the denoised layer directly from the imputed data
output.layers["denoised"] = cmap.query_imputed.X

output.write_h5ad(par['output'], compression='gzip')
